import {
  computed,
  ShallowReactive,
  shallowReactive,
  shallowReadonly,
  watch,
} from 'vue'
import { isFunction } from './utils/isFunction.js'
import { isThenable } from './utils/isThenable.js'
import { tryInvoke } from './utils/tryInvoke.js'

export type Status = 'pending' | 'fulfilled' | 'rejected'

type StatusMap = { [K in Status]: K }

const STATUS: StatusMap = {
  pending: 'pending',
  fulfilled: 'fulfilled',
  rejected: 'rejected',
}

/** Represents value for `this` in getter functions. */
export interface AsyncGetterThis {
  /**
   * {@link AbortSignal} that will be marked as aborted as soon as the input
   * values for the computed function change and new getter call is made,
   * because that would mean that the return value of the current asynchronous
   * getter will be discarded.
   *
   * You can pass this signal to `fetch` calls and other APIs that accept
   * {@link AbortSignal}s to prevent them from doing unnecessary job.
   */
  signal: AbortSignal
}

/**
 * Represents an options object that is used as an argument for the
 * {@link asyncComputed}.
 *
 * @template R The fulfilled value of the promise that later becomes accessible
 *   through {@link FulfilledState.value} property.
 * @template S The value generated by watch method and provided to the getter
 *   method as an argument.
 */
export interface AsyncComputedOptions<R, S> {
  /**
   * A watch function that when called directly accesses other reactive
   * references to set up watchers and returns {@link S}.
   *
   * Use watch method whenever references are not accessed before the first
   * asynchronous operation in the getter method, otherwise Vue won't be able to
   * subscribe the getter for updates.
   *
   * Alternatively, you can refactor your getter function to access the reactive
   * references before any asynchronous operations, but in most cases such
   * hoisting makes code look less clear.
   */
  watch?(): S

  /**
   * @param this Context for the getter that contains {@link AbortSignal}.
   * @param source Value generated by the watch function.
   */
  get(this: AsyncGetterThis, source: S): R | PromiseLike<R>
}

/**
 * Represents a getter function that is used as an argument for the
 * {@link asyncComputed}.
 *
 * @template R The value of the promise that later becomes accessible through
 *   {@link FulfilledState.value} property.
 */
export type AsyncComputedGetter<R> = (
  this: AsyncGetterThis,
) => R | PromiseLike<R>

/** Represent a base state object which should be used by extending interfaces. */
export interface StateBase<R> {
  /** The status of promise from the latest reactive invocation. */
  status: Status

  /**
   * The promise for the latest reactive invocation.
   *
   * It is always a promise that resolves to the original value returned by the
   * getter function or method (regardless whether it was a promise or not).
   */
  promise: Promise<R>

  /** Value that the promise has been fulfilled with. */
  value: unknown

  /** Rejection reason that the promise settled with. */
  error: unknown

  /** @returns Whether the promise has not been settled yet. */
  get pending(): this['status'] extends StatusMap['pending'] ? true : false

  /** @returns Whether the promise has been fulfilled and value is available. */
  get fulfilled(): this['status'] extends StatusMap['fulfilled'] ? true : false

  /**
   * @returns Whether the promise has been rejected and error (rejection reason)
   *   is available.
   */
  get rejected(): this['status'] extends StatusMap['rejected'] ? true : false
}

/** Represents a state object for yet unsettled promise. */
export interface PendingState<R> extends StateBase<R> {
  status: StatusMap['pending']

  value: undefined

  error: undefined
}

/** Represents a state object for the settled promise with available value. */
export interface FulfilledState<R> extends StateBase<R> {
  status: StatusMap['fulfilled']

  value: R

  error: undefined
}

/** Represents a state object for the rejected promise. */
export interface RejectedState<R> extends StateBase<R> {
  status: StatusMap['rejected']

  value: undefined

  error: unknown
}

/** Represents a union of state object in different states. */
export type State<R> = PendingState<R> | FulfilledState<R> | RejectedState<R>

export type AsyncComputedRef<R = any> = Readonly<ShallowReactive<State<R>>>

/**
 * {@link asyncComputed} takes in an asynchronous getter function or an object
 * containing asynchronous getter method and optionally a synchronous method to
 * watch and return references to be used within the asynchronous getter, and
 * then returns a read-only state object, containing the current state, value or
 * rejection reason.
 *
 * `this` for getters is set to {@link AsyncGetterThis}, which contains
 * {@link AbortSignal} used to indicate that the watched values have changed and
 * therefore the returned value will be discarded after the promise settles. You
 * can pass it to `fetch` or other APIs to prevent them from performing no
 * longer necessary work.
 *
 * @example
 *   import { ref, watchEffect } from 'vue'
 *   import { asyncComputed } from '@braw/async-computed'
 *
 *   const $count = ref(0)
 *
 *   const multiplication = asyncComputed({
 *     watch() {
 *       return { count: $count.value }
 *     },
 *     async get({ count }) {
 *       // imitate the slowness
 *       await new Promise((resolve) =>
 *         setTimeout(() => resolve(), Math.random() * 2000),
 *       )
 *
 *       if (Math.random() > 0.8) {
 *         throw new Error('Random is not on your side right now.')
 *       }
 *
 *       return count * 2
 *     },
 *   })
 *
 *   watchEffect(() => {
 *     if (multiplication.fulfilled) {
 *       console.log(
 *         `The multiplied value of ${$count.value} is ${multiplication.value}`,
 *       )
 *     } else if (multiplication.rejected) {
 *       console.warning(
 *         `Failed to calculate the multiplied value of ${$count.value}: ${multiplication.error}`,
 *       )
 *     }
 *   })
 *
 * @param getterOrOptions Either a function that returns a promise, or an object
 *   containing a method that returns a promise, and optionally a method that
 *   synchronously maps values for other reactive references, which then passed
 *   to the getter method.
 */
export function asyncComputed<R, S = any>(
  getterOrOptions: AsyncComputedGetter<R> | AsyncComputedOptions<R, S>,
): AsyncComputedRef<R> {
  const state = shallowReactive<State<R>>({
    get pending() {
      return (this.status as Status) === STATUS.pending
    },
    get fulfilled() {
      return (this.status as Status) === STATUS.fulfilled
    },
    get rejected() {
      return (this.status as Status) === STATUS.rejected
    },
  } as State<R>)

  function setPending(promise: Promise<R>) {
    Object.assign(state, {
      status: STATUS.pending,
      value: undefined,
      error: undefined,
      promise,
    } as const) satisfies State<R> & PendingState<R>
  }

  function setFulfilled<R>(promise: Promise<R>, value: R) {
    Object.assign(state, {
      status: STATUS.fulfilled,
      value,
      error: undefined,
      promise,
    } as const) satisfies State<R> & FulfilledState<R>
  }

  function setRejected(promise: Promise<R>, error: unknown) {
    Object.assign(state, {
      status: STATUS.rejected,
      value: undefined,
      error,
      promise,
    } as const) satisfies State<R> & RejectedState<R>
  }

  const source = computed<S>(() => {
    if (isFunction(getterOrOptions) || getterOrOptions.watch == null) {
      return undefined as S
    }

    return getterOrOptions.watch()
  })

  const invocation = computed(() => {
    const abortController = new AbortController()

    const thisValue: AsyncGetterThis = {
      signal: abortController.signal,
    }

    return {
      ...thisValue,
      result: isFunction(getterOrOptions)
        ? tryInvoke(getterOrOptions.bind(thisValue))
        : tryInvoke(getterOrOptions.get.bind(thisValue, source.value)),
      cancel() {
        abortController.abort()
      },
    }
  })

  watch(
    () => invocation.value,
    (activeInvocation, previousInvocation) => {
      previousInvocation?.cancel()

      const { result, signal } = activeInvocation

      if (!result.ok) {
        setRejected(Promise.reject(result.value), result.value)
        return
      }

      if (isThenable(result.value)) {
        const handledPromise = Promise.resolve(result.value).then(
          (value) => {
            if (!signal.aborted) setFulfilled(handledPromise, value)

            return value
          },
          (error) => {
            if (!signal.aborted) setRejected(handledPromise, error)

            throw error
          },
        )

        setPending(handledPromise)
      } else {
        setFulfilled(Promise.resolve(result.value), result.value)
      }
    },
    {
      immediate: true,
      flush: 'sync',
    },
  )

  return shallowReadonly(state)
}
