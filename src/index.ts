import {
  computed,
  ShallowReactive,
  shallowReactive,
  shallowReadonly,
  watch,
} from 'vue'

export enum State {
  /** The promise is pending resolution. */
  Pending = 'pending',

  /** The promise has been resolved. */
  Resolved = 'resolved',

  /** The promise has encountered an error. */
  Rejected = 'rejected',
}

/** Represents value for `this` in getter functions. */
export interface AsyncGetterThis {
  /**
   * {@link AbortSignal} that will be marked as aborted as soon as the input
   * values for the computed function change and new getter call is made,
   * because that would mean that the return value of the current asynchronous
   * getter will be discarded.
   *
   * You can pass this signal to `fetch` calls and other APIs that accept
   * {@link AbortSignal}s to prevent them from doing unnecessary job.
   */
  signal: AbortSignal
}

/**
 * Represents an options object that is used as an argument for the
 * {@link asyncComputed}.
 *
 * @template R The resolved value of the promise that later becomes accessible
 *   through {@link ResolvedStateObject.value} property.
 * @template S The value generated by watch method and provided to the getter
 *   method as an argument.
 */
export interface AsyncComputedOptions<R, S> {
  /**
   * A watch function that when called directly accesses other reactive
   * references to set up watchers and returns {@link S}.
   *
   * Use watch method whenever references are not accessed before the first
   * asynchorous operation in the getter method, otherwise Vue won't be able to
   * subscribe the getter for updates.
   *
   * Alternatively, you can refactor your getter function to access the reactive
   * references before any asynchorous operations, but in most cases such
   * hoisting makes code look less clear.
   */
  watch?(): S

  /**
   * @param this Context for the getter that contains {@link AbortSignal}.
   * @param source Value generated by the watch function.
   */
  get(this: AsyncGetterThis, source: S): R | PromiseLike<R>
}

/**
 * Represents a getter function that is used as an argument for the
 * {@link asyncComputed}.
 *
 * @template R The resolved value of the promise that later becomes accessible
 *   through {@link ResolvedStateObject.value} property.
 */
export type AsyncComputedGetter<R> = (
  this: AsyncGetterThis,
) => R | PromiseLike<R>

/** Represent a base state object which should be used by extending interfaces. */
export interface StateObjectBase<R> {
  /** Represents the current state of the reference. */
  state: State

  /** The original promise. */
  promise: Promise<R>

  value: unknown

  error: unknown

  /** @returns Whether the promise has not been resolved yet. */
  get isPending(): this['state'] extends State.Pending ? true : false

  /** @returns Whether the promise has been resolved and value is available. */
  get isResolved(): this['state'] extends State.Resolved ? true : false

  /**
   * @returns Whether the promise has been rejected and error (rejection reason)
   *   is available.
   */
  get isRejected(): this['state'] extends State.Rejected ? true : false
}

/** Represents a state object for yet unresolved promise. */
export interface PendingStateObject<R> extends StateObjectBase<R> {
  state: State.Pending

  value: undefined

  error: undefined
}

/** Represents a state oject for the resolved promise. */
export interface ResolvedStateObject<R> extends StateObjectBase<R> {
  state: State.Resolved

  /** Resolved value of the promise. */
  value: R

  /** Rejection reason. */
  error: undefined
}

/** Represents a state object for the rejected promise. */
export interface RejectedStateObject<R> extends StateObjectBase<R> {
  state: State.Rejected

  /** Resolved value of the promise. */
  value: undefined

  /** Rejection reason. */
  error: unknown
}

export type StateObject<R> =
  | PendingStateObject<R>
  | ResolvedStateObject<R>
  | RejectedStateObject<R>

export type AsyncComputedRef<R = any> = Readonly<
  ShallowReactive<StateObject<R>>
>

type Result<T> =
  | {
      result: 'complete'
      value: T
    }
  | {
      result: 'throw'
      error: unknown
    }

function invoke<T>(func: () => T): Result<T> {
  try {
    return {
      result: 'complete',
      value: func(),
    }
  } catch (error) {
    return {
      result: 'throw',
      error,
    }
  }
}

/**
 * Checks whether the provided value is an instance of Thenable.
 *
 * Thenables are regular objects containing.
 *
 * @param value Value to check.
 * @returns `true` if value is thenable.
 */
function isThenable(value: unknown): value is PromiseLike<unknown> {
  return (
    typeof value === 'object' &&
    value !== null &&
    typeof (value as Record<PropertyKey, any>).then === 'function'
  )
}

/**
 * {@link asyncComputed} takes in an asyncronous getter function or an object
 * containing asynchoronous getter method and optionally a synchronous method to
 * watch and return references to be used within the asynchoronous getter, and
 * then returns a read-only state object, containing the current state, resolved
 * value or rejection reason.
 *
 * `this` for getters is set to {@link AsyncGetterThis}, which contains
 * {@link AbortSignal} used to indicate that the watched values have changed and
 * therefore the returned value will be discarded after the promise gets
 * resolved/rejected. You can pass it to `fetch` or other APIs to prevent them
 * from performing no longer necessary work.
 *
 * @example
 *   import { ref, watchEffect } from 'vue'
 *   import { asyncComputed } from '@braw/async-computed'
 *
 *   const counter = ref(0)
 *
 *   const multiplication = asyncComputed({
 *     watch() {
 *       return counter.value
 *     },
 *     async get(count) {
 *       // immitate the slowness
 *       await new Promise((resolve) =>
 *         setTimeout(() => resolve(), Math.random() * 2000),
 *       )
 *
 *       if (Math.random() > 0.8) {
 *         throw new Error('Random is not on your side right now.')
 *       }
 *
 *       return count * 2
 *     },
 *   })
 *
 *   watchEffect(() => {
 *     if (multiplication.isResolved) {
 *       console.log(
 *         `The multiplied value of ${counter.value} is ${multiplication.value}`,
 *       )
 *     } else if (multiplication.isRejected) {
 *       console.warning(
 *         `Failed to calculate the multiplied value of ${counter.value}: ${multiplication.error}`,
 *       )
 *     }
 *   })
 *
 * @param getterOrOptions Either a function that returns a promise, or an object
 *   containing a method that returns a promise, and optionally a method that
 *   synchronously maps values for other reactive references, which then passed
 *   to the getter method.
 */
export function asyncComputed<R, S = any>(
  getterOrOptions: AsyncComputedGetter<R> | AsyncComputedOptions<R, S>,
): AsyncComputedRef<R> {
  const state = shallowReactive<StateObject<R>>({
    get isPending() {
      return (this.state as State) === State.Pending
    },
    get isResolved() {
      return (this.state as State) === State.Resolved
    },
    get isRejected() {
      return (this.state as State) === State.Rejected
    },
  } as StateObject<R>)

  function setPending(promise: Promise<R>) {
    Object.assign(state, {
      state: State.Pending as const,
      value: undefined,
      error: undefined,
      promise,
    }) satisfies StateObject<R> & PendingStateObject<R>
  }

  function setResolved<R>(promise: Promise<R>, value: R) {
    Object.assign(state, {
      state: State.Resolved as const,
      value,
      error: undefined,
      promise,
    }) satisfies StateObject<R> & ResolvedStateObject<R>
  }

  function setError(promise: Promise<R>, error: unknown) {
    Object.assign(state, {
      state: State.Rejected as const,
      value: undefined,
      error,
      promise,
    }) satisfies StateObject<R> & RejectedStateObject<R>
  }

  const source = computed<S>(() => {
    if (
      typeof getterOrOptions === 'function' ||
      getterOrOptions.watch == null
    ) {
      return undefined as S
    }

    return getterOrOptions.watch()
  })

  const invokation = computed(() => {
    const abortController = new AbortController()
    const thisValue: AsyncGetterThis = {
      signal: abortController.signal,
    }

    return {
      invokation:
        typeof getterOrOptions === 'function'
          ? invoke(getterOrOptions.bind(thisValue))
          : invoke(getterOrOptions.get.bind(thisValue, source.value)),
      abortController,
    }
  })

  watch(
    () => invokation.value,
    (activeInvokation, previousInvokation) => {
      previousInvokation?.abortController.abort()

      const {
        invokation,
        abortController: { signal },
      } = activeInvokation

      if (invokation.result === 'throw') {
        setError(Promise.reject(invokation.error), invokation.error)
        return
      }

      if (isThenable(invokation.value)) {
        const handledPromise = Promise.resolve(invokation.value).then(
          (value) => {
            if (!signal.aborted) setResolved(handledPromise, value)

            return value
          },
          (error) => {
            if (!signal.aborted) setError(handledPromise, error)

            throw error
          },
        )

        setPending(handledPromise)
      } else {
        setResolved(Promise.resolve(invokation.value), invokation.value)
      }
    },
    {
      immediate: true,
      flush: 'sync',
    },
  )

  return shallowReadonly(state)
}
