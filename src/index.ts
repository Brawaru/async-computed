import {
  computed,
  ShallowReactive,
  shallowReactive,
  shallowReadonly,
  watch,
} from 'vue'

export enum State {
  /** The promise is pending resolution. */
  Pending = 'pending',

  /** The promise has been resolved. */
  Resolved = 'resolved',

  /** The promise has encountered an error. */
  Rejected = 'rejected',
}

/**
 * Represents an options object that is used as an argument for the
 * {@link asyncComputed}, containing both watch and getter methods.
 *
 * @template R The resolved value of the promise that later becomes accessible
 *   through {@link ResolvedStateObject.value} property.
 * @template S The value generated by watch method and provided to the getter
 *   method as an argument.
 */
export interface AsyncComputedOptions<R, S> {
  /**
   * A watch function that when called directly accesses other reactive
   * references to set up watchers and returns {@link S}.
   *
   * Use watch method whenever references are not accessed before the first
   * asynchorous operation in the getter method, otherwise Vue won't be able to
   * subscribe the getter for updates. You can refactor your getter to access
   * the reactive references before any asynchorous operation, but in most cases
   * it makes code less clear.
   */
  watch(): S

  get(source: S, signal: AbortSignal): R | PromiseLike<R>
}

/**
 * Represents an options object that is used as an argument for the
 * {@link asyncComputed}, containing only the getter.
 *
 * @template R The resolved value of the promise that later becomes accessible
 *   through {@link ResolvedStateObject.value} property.
 */
export interface AsyncComputedOptionsGetterOnly<R> {
  get(signal: AbortSignal): R | PromiseLike<R>
}

/**
 * Represents a getter function that is used as an argument for the
 * {@link asyncComputed}.
 *
 * @template R The resolved value of the promise that later becomes accessible
 *   through {@link ResolvedStateObject.value} property.
 */
export type AsyncComputedGetter<R> = (signal: AbortSignal) => R | Promise<R>

/** Represent a base state object which should be used by extending interfaces. */
export interface StateObjectBase<R> {
  /** Represents the current state of the reference. */
  state: State

  /** The original promise. */
  promise: Promise<R>

  /** @returns Whether the promise has not been resolved yet. */
  get isPending(): this['state'] extends State.Pending ? true : false

  /** @returns Whether the promise has been resolved and value is available. */
  get isResolved(): this['state'] extends State.Resolved ? true : false

  /**
   * @returns Whether the promise has been rejected and error (rejection reason)
   *   is available.
   */
  get isRejected(): this['state'] extends State.Rejected ? true : false
}

/** Represents a state object for yet unresolved promise. */
export interface PendingStateObject<R> extends StateObjectBase<R> {
  state: State.Pending
}

/** Represents a state oject for the resolved promise. */
export interface ResolvedStateObject<R> extends StateObjectBase<R> {
  state: State.Resolved

  /** Resolved value of the promise. */
  value: R
}

/** Represents a state object for the rejected promise. */
export interface RejectedStateObject<R> extends StateObjectBase<R> {
  state: State.Rejected

  /** Rejection reason. */
  error: unknown
}

export type StateObject<R> =
  | PendingStateObject<R>
  | ResolvedStateObject<R>
  | RejectedStateObject<R>

export type AsyncComputedRef<R = any> = Readonly<
  ShallowReactive<StateObject<R>>
>

/**
 * {@link asyncComputed} takes in an asyncronous getter function or an object
 * containing asynchoronous getter method and optionally a synchronous method to
 * watch and return references to be used within the asynchoronous getter, and
 * then returns a read-only state object, containing the current state, resolved
 * value or rejection reason.
 *
 * All getters receive an {@link AbortSignal} used to indicate that the watched
 * values have changed and therefore returned value will be discarded. You can
 * use that signal for fetch requests.
 *
 * @example
 *   import { ref, watchEffect } from 'vue'
 *   import { asyncComputed } from '@braw/async-computed'
 *
 *   const counter = ref(0)
 *
 *   const multiplication = asyncComputed({
 *     watch() {
 *       return counter.value
 *     },
 *     async get(count) {
 *       // immitate the slowness
 *       await new Promise((resolve) =>
 *         setTimeout(() => resolve(), Math.random() * 2000),
 *       )
 *
 *       if (Math.random() > 0.8) {
 *         throw new Error('Random is not on your side right now.')
 *       }
 *
 *       return count * 2
 *     },
 *   })
 *
 *   watchEffect(() => {
 *     if (multiplication.isResolved) {
 *       console.log(
 *         `The multiplied value of ${counter.value} is ${multiplication.value}`,
 *       )
 *     } else if (multiplication.isRejected) {
 *       console.warning(
 *         `Failed to calculate the multiplied value of ${counter.value}: ${multiplication.error}`,
 *       )
 *     }
 *   })
 *
 * @param getterOrOptions Either a function that returns a promise, or an object
 *   containing a method that returns a promise, and optionally a method that
 *   synchronously maps values for other reactive references, which then passed
 *   to the getter method.
 */
export function asyncComputed<S, R = any>(
  getterOrOptions:
    | AsyncComputedGetter<R>
    | AsyncComputedOptions<R, S>
    | AsyncComputedOptionsGetterOnly<R>,
): AsyncComputedRef<R> {
  const state = shallowReactive<StateObject<R>>({
    state: State.Pending,
    value: undefined,
    error: undefined,
    promise: undefined as unknown as Promise<R>,
    get isPending() {
      return (this.state as State) === State.Pending
    },
    get isResolved() {
      return (this.state as State) === State.Resolved
    },
    get isRejected() {
      return (this.state as State) === State.Rejected
    },
  } as StateObject<R>)

  const source = computed(() => {
    if (
      typeof getterOrOptions === 'function' ||
      !('watch' in getterOrOptions)
    ) {
      return undefined
    }

    return {
      value: getterOrOptions.watch(),
    }
  })

  const invokation = computed(() => {
    const abortController = new AbortController()

    if (typeof getterOrOptions === 'function') {
      return {
        promise: Promise.resolve(getterOrOptions(abortController.signal)),
        abortController,
      }
    }

    if ('watch' in getterOrOptions) {
      return {
        promise: Promise.resolve(
          getterOrOptions.get(source.value!.value, abortController.signal),
        ),
        abortController,
      }
    } else {
      return {
        promise: Promise.resolve(getterOrOptions.get(abortController.signal)),
        abortController,
      }
    }
  })

  watch(
    () => invokation.value,
    (activeInvokation, previousInvokation) => {
      previousInvokation?.abortController.abort()

      const {
        promise,
        abortController: { signal },
      } = activeInvokation

      Object.assign(state, {
        state: State.Pending,
        value: undefined,
        error: undefined,
        promise,
      } as unknown)

      promise
        .then((value) => {
          if (!signal.aborted) {
            Object.assign(state, {
              state: State.Resolved,
              value,
              error: undefined,
            } as unknown)

            console.log('resolved', state)
          }
        })
        .catch((error) => {
          if (!signal.aborted) {
            Object.assign(state, {
              state: State.Rejected,
              value: undefined,
              error,
            } as unknown)

            console.log('rejected', state)
          }
        })
    },
    {
      immediate: true,
    },
  )

  return shallowReadonly(state)
}
